<?phpdeclare( strict_types = 1 );namespace Checking;use Ctce\Evaluator;use Diagnostic;use Lexing\Position;use MatchArm;use Typing\AnonymousUnion;use Typing\Describer;use Typing\DescriberUsage;use Typing\Description;use Typing\Description as Desc;use Typing\InstanceChecker;use Typing\InstanceCheckerUsage;use Typing\PresenterUsage;use Typing\SamenessChecker;use Typing\Type;class StmtResult {   public ?Diagnostic $err = null;   public \ExprStmt $exprStmt;   public bool $evaluable = false;   public bool $constant = false;}class SimpleExprChecker {   use DescriberUsage;   use PresenterUsage;   use InstanceCheckerUsage;   private \User $user;   private \Scope $scope;   private \Task $task;   private \Typing\TypeChecker $typeChecker;   private ModuleChecker $moduleChecker;   private DeclChecker $declChecker;   private ExprChecker $exprChecker;   /**    * @var \Node[]    */   private array $unresolvedFuncs;   /** @var \Module[]  */   private array $unresolvedFuncsOwners;   private ?\Func $func;   public function __construct( \Scope $scope, \Task $task,      \Typing\TypeChecker $typeChecker,      private Describer $typeDescriber,      private \Typing\Presenter $typePresenter,      private InstanceChecker $instanceChecker,      private SamenessChecker $samenessChecker,      private Evaluator $evaluator ) {      $this->user = $task->user;      $this->scope = $scope;      $this->task = $task;      $this->typeChecker = $typeChecker;      $this->unresolvedFuncs = [];      $this->unresolvedFuncsOwners = [];   }   public function setCheckers( ModuleChecker $moduleChecker,      DeclChecker $declChecker, ExprChecker $exprChecker ): void {      $this->moduleChecker = $moduleChecker;      $this->declChecker = $declChecker;      $this->exprChecker = $exprChecker;   }   public function checkSimpleExpr( \Node $node ): Value {      if ( $node instanceof \Let ) {         return $this->checkLet( $node );      }      else if ( $node instanceof \Assignment ) {         return $this->checkAssignment( $node );      }      else if ( $node instanceof \Binary ) {         return $this->checkBinary( $node );      }      else if ( $node instanceof \Logical ) {         return $this->checkLogical( $node );      }      else if ( $node instanceof \LogicalNot ) {         return $this->checkLogicalNot( $node );      }      else {         return $this->checkPrefix( $node );      }   }   private function isInstanceOf( Value $instance, Type $type ): bool {      return $this->instanceChecker->isInstanceOf( $instance, $type );   }   public function checkLet( \Let $let ): Value {      foreach ( $let->unpackedTuple as $param ) {         // Check binding type.         $type = $this->exprChecker->checkTypeExpr(            $param->expectedTypeExpr );         $param->type = $type;         $expectedType = $param->type;         if ( $param->defaultArg !== null ) {            $value = $this->checkExpr( $param->defaultArg );            if ( $param->type !== null ) {               //var_dump( $this->typeChecker->presentType( $value->type ) );               //var_dump( $this->typeChecker->presentType( $value->type ) );               if ( ! $this->isInstanceOf( $value, $param->type ) ) {                  $this->err( $param->defaultArg->pos,                     "value type (`%s`) different from binding type (`%s`)",                     $this->presentType( $value->type ),                     $this->presentType( $param->type ) );               }            }            else {               $param->type = $value->type;               $param->expectedValue = $value;            }         }         else {            $value = new Value();            $param->type = $value->type;            $param->expectedValue = $value;         }         $binding = $this->scope->bind( $param->name, $param );         $binding->rebindable = $param->rebindable;         $binding->expectedType = $expectedType;         $binding->value = $value;         $value->binding = $binding;         //$value->type = $param->type;      }      if ( $let->value !== null ) {         $initz = $this->checkExpr( $let->value );      }      return $value;      /*      if ( $binding->object->binding != null ) {         $binding->object->binding->moved = true;      }*/   }   private function checkAssignment( \Assignment $assignment ): Value {      $lside = $this->checkSuffix( $assignment->lside );      $rside = $this->checkSimpleExpr( $assignment->rside );/*      if ( $lside->binding == null ) {         printf( "error: cannot assign to left side\n" );         throw new Exception();      }      $lside->binding->type = $rside->type;      $lside->binding->initialized = true;*/      if ( ! ( $lside->binding !== null && $lside->binding->rebindable ) &&         ! $lside->mutableBinding ) {         $this->err( $assignment->pos,            'cannot assign to left side because it is immutable' );      }      if ( $lside->virtual ) {         if ( ! $rside->constant ) {            $this->user->diag( DIAG_ERR, $assignment->pos,               "virtual assignment requires a constant right-side operand" );            $this->user->bail();         }         if ( $lside->container !== null ) {            $lside->container->refinements[ $lside->memberName ] = $rside;//               var_dump( $lside->type->refinements[ 'a' ] ->value );         }      }/*      if ( $rside->binding != null ) {         $rside->binding->object = new MovedValue();      }*/      $lsideType = $lside->type;      if ( $lside->binding !== null ) {         if ( $lside->binding->expectedType !== null ) {            $lsideType = $lside->binding->expectedType;         }      }      else if ( $lside->member !== null ) {         $lsideType = $lside->member->type;      }      else {         $this->err( $assignment->pos,            "left side of assignment must be label" );      }      if ( ! $this->isVoid( $lsideType ) &&         ! $this->isInstanceOf( $rside, $lsideType ) ) {         $this->err( $assignment->pos,            "type of value (`%s`) different from binding type (`%s`)",            $this->presentType( $rside->type ),            $this->presentType( $lsideType ) );      }      $result = new Value();      $result->type = $rside->type;      $result->evaluable = ( $lside->evaluable && $rside->evaluable );      $result->assigned = true;      if ( $lside->binding !== null ) {         //$lside->binding->type = $rside->type;         $lside->binding->initialized = true;         $lside->binding->value = $result;         //$lside->let->object = $result;         //$lside->let->binding->value = $result;      }      else if ( $lside->member !== null ) {         $lside->type = $rside->type;      }/*      if ( $rside->let !== null ) {         $rside->let->object = new Result();         $rside->let->type = $rside->let->object->type;         if ( $rside->let->binding !== null ) {            $rside->let->binding->value = null;         }      }*/      if ( $rside->binding !== null ) {         $rside->binding->value = new Value();      }      return $result;   }   private function checkLogical( \Logical $logical ): Value {      switch ( $logical->operator ) {      case \Logical::OPERATOR_AND:         $this->scope->enter( SCOPE_AND );         break;      default:         $this->scope->enter( SCOPE_OR );      }      $lside = $this->checkSimpleExpr( $logical->lside );      if ( $this->describe( $lside ) !== Desc::BOOL ) {         $this->err( $logical->pos,            'left side must be of `Bool` type' );      }      if ( $logical->lside instanceof \Logical &&         $logical->lside->operator != $logical->operator ) {         $this->err( $logical->pos,            'parentheses required when different logical ' .            'operators are used together' );      }      $this->scope->enter( SCOPE_RSIDE );      $rside = $this->checkSimpleExpr( $logical->rside );      $this->scope->leave();      if ( $this->describe( $rside ) !== DESC::BOOL ) {         $this->err( $logical->pos,            'right side must be of `Bool` type' );      }      /*      switch ( $logical->operator ) {      case Logical::OPERATOR_OR:         // For chained OR's, the bindings created in a previous OR should         // still be valid in a following OR. The scope of the right side of         // the current OR operation extends into the following OR operation.         if ( ! ( $check != null && $check->parentLogical != null &&            $check->parentLogical->operator == Logical::OPERATOR_OR ) ) {            printf( "closing " );            var_dump( $lsideCheck->scopeId );            $this->scope->popTarget( $lsideCheck->scopeId );         }         break;      }      */      $this->scope->leave();      $result = new Value();      $result->type = $lside->type;      $result->evaluable = ( $lside->evaluable && $rside->evaluable );      return $result;   }   private function checkLogicalNot( \LogicalNot $logicalNot ): Value {      $operand = $this->checkSimpleExpr( $logicalNot->operand );      switch ( $this->describe( $operand ) ) {      case DESC::BOOL:         $result = new Value();         $result->type = $operand->type;         $result->evaluable = $operand->evaluable;         return $result;      case DESC::ERR:         return $operand;      default:         return $this->err( $logicalNot->pos,            'operand for `not` operator must be of Bool type' );      }   }   private function isValidCall( \Func $func, array $args ): bool {      $i = 0;      foreach ( $func->params as $param ) {         if ( ! $this->isInstanceOf( $args[ $i ], $param->type ) ) {            break;         }         ++$i;      }      return ( $i == count( $func->params ) );   }   private function checkBinary( \Binary $binary ): Value {      $lside = $this->checkSimpleExpr( $binary->lside );      $rside = $this->checkSimpleExpr( $binary->rside );      switch ( $this->describe( $lside ) ) {      case Desc::INT:         return $this->checkBinaryInt( $binary, $lside, $rside );      case Desc::UNCHECKED_INT:         return $this->checkBinaryUncheckedInt( $binary, $lside, $rside );      case Desc::BOOL:         return $this->checkBinaryBool( $binary, $lside, $rside );      case Desc::STR:         return $this->checkBinaryStr( $binary, $lside, $rside );      case Desc::PTR:         return $this->checkBinaryPtr( $binary, $lside, $rside );      case Desc::STRUCT:         return $this->checkBinaryStruct( $binary, $lside, $rside );      case Desc::STRUCT_INFO:         return $this->checkBinaryStructInfo( $binary, $lside, $rside );      default:         $this->err( $binary->pos,            "invalid binary operation (`%s` %s `%s`)",            $this->presentType( $lside->type ), $binary->presentOperator(),            $this->presentType( $rside->type ) );      }   }   private function err( Position $pos, string $message, ... $args ): never {      $result = new Value();      $result->type->spec = TYPESPEC_ERR;      $result->diag = $this->user->diag( DIAG_ERR, $pos, $message,         ... $args );      throw new CheckErr( $result );   }   private function checkBinaryInt( \Binary $binary, Value $lside,      Value $rside ): Value {      $valid = false;      switch ( $binary->op ) {      case \Binary::OP_ADD:         switch ( $this->describe( $rside ) ) {         case Desc::INT:         case Desc::PTR:            $valid = true;         }         break;      default:         if ( $this->describe( $rside ) === Desc::INT ) {            $valid = true;         }      }      if ( ! $valid ) {         return $this->err( $binary->pos,            "invalid operation: `%s` %s `%s`",            $this->presentType( $lside->type ), $binary->presentOperator(),            $this->presentType( $rside->type ) );      }      $result = new Value();      $result->evaluable = ( $lside->evaluable && $rside->evaluable );      $result->constant = ( $lside->constant && $rside->constant );      switch ( $binary->op ) {      case \Binary::OP_EQ:         $result->type = $this->createBoolType();         if ( $result->constant ) {            $result->inhabitant = $lside->inhabitant === $rside->inhabitant ? 1 : 0;            $result->type->value = $result->inhabitant;            if ( $lside->binding !== null && $result->inhabitant === 1 ) {               $refinement = new \Refinement();               $refinement->target = $lside->binding->name;               $refinement->type = $rside->type;               $result->type->refinements[] = $refinement;            }         }         else {            if ( $lside->binding !== null ) {               $true = new Value();               $true->type = $this->createBoolType();               $true->inhabitant = 1;               $refinement = new \Refinement();               $refinement->target = $lside->binding->name;               $refinement->type = $rside->type;               $refinement->result = $true;               $result->type->refinements[] = $refinement;            }         }         $result->type->unchecked = true;         break;      case \Binary::OP_NEQ:         $result->type = $this->createBoolType();         if ( $result->constant ) {            $result->inhabitant = $lside->inhabitant !== $rside->inhabitant ? 1 : 0;            $result->type->value = $result->inhabitant;         }         break;      case \Binary::OP_LT:         $result->type = $this->createBoolType();         if ( $result->constant ) {            $result->inhabitant = $lside->inhabitant < $rside->inhabitant ? 1 : 0;            $result->type->value = $result->inhabitant;         }         break;      case \Binary::OP_LTE:         $result->type = $this->createBoolType();         if ( $result->constant ) {            $result->inhabitant = $lside->inhabitant <= $rside->inhabitant ? 1 : 0;            $result->type->value = $result->inhabitant;         }         break;      case \Binary::OP_GT:         $result->type = $this->createBoolType();         if ( $result->constant ) {            $result->inhabitant = $lside->inhabitant > $rside->inhabitant ? 1 : 0;            $result->type->value = $result->inhabitant;         }         break;      case \Binary::OP_GTE:         $result->type = $this->createBoolType();         if ( $result->constant ) {            $result->inhabitant = $lside->inhabitant >= $rside->inhabitant ? 1 : 0;            $result->type->value = $result->inhabitant;         }         break;      case \Binary::OP_ADD:         if ( $this->describe( $rside ) === Desc::PTR ) {            $result->type = $rside->type;         }         else {            $result->type = $this->createIntType();            $result->type->unchecked = true;            if ( $result->constant ) {               $result->inhabitant = $lside->inhabitant + $rside->inhabitant;               $result->type->value = $result->inhabitant;            }         }         break;      case \Binary::OP_SUB:         $result->type = $this->createIntType();         if ( $result->constant ) {            $result->inhabitant = $lside->inhabitant - $rside->inhabitant;            $result->type->value = $result->inhabitant;         }         break;      case \Binary::OP_MUL:         $result->type = $this->createIntType();         if ( $result->constant ) {            $result->inhabitant = $lside->inhabitant * $rside->inhabitant;            $result->type->value = $result->inhabitant;         }         break;      case \Binary::OP_DIV:         $result->type = $this->createIntType();         if ( $result->constant ) {            $result->inhabitant = intdiv( $lside->inhabitant, $rside->inhabitant );            $result->type->value = $result->inhabitant;         }         break;      case \Binary::OP_MOD:         $result->type = $this->createIntType();         if ( $result->constant ) {            $result->inhabitant = $lside->inhabitant % $rside->inhabitant;            $result->type->value = $result->inhabitant;         }         break;      default:         UNREACHABLE();      }      $binary->implementer = \Implementer::INT;      $binary->type = $result->type;      return $result;   }   private function checkBinaryUncheckedInt( \Binary $binary, Value $lside,      Value $rside ): Value {      $valid = false;      switch ( $binary->op ) {      case \Binary::OP_LT:      case \Binary::OP_LTE:      case \Binary::OP_GT:      case \Binary::OP_GTE:         break;      default:         switch ( $this->describe( $rside ) ) {         case Desc::INT:         case Desc::UNCHECKED_INT:            $valid = true;            break;         }      }      if ( ! $valid ) {         return $this->err( $binary->pos,            "invalid operation: `%s` %s `%s`",            $this->presentType( $lside->type ),            $binary->presentOperator(),            $this->presentType( $rside->type ) );      }      $result = new Value();      $result->evaluable = ( $lside->evaluable && $rside->evaluable );      $result->constant = ( $lside->constant && $rside->constant );      switch ( $binary->op ) {      case \Binary::OP_EQ:         $result->type = $this->createBoolType();         if ( $result->constant ) {            $result->inhabitant = $lside->inhabitant === $rside->inhabitant ? 1 : 0;            $result->type->value = $result->inhabitant;         }         if ( $lside->binding !== null && $rside->constant ) {            $refinement = new \Refinement();            $refinement->target = $lside->binding->name;            $refinement->type = $rside->type;            $result->type->refinements[] = $refinement;         }         break;      case \Binary::OP_NEQ:         $result->type = $this->createBoolType();         if ( $result->constant ) {            $result->inhabitant = $lside->inhabitant !== $rside->inhabitant ? 1 : 0;            $result->type->value = $result->inhabitant;         }         break;      case \Binary::OP_ADD:         if ( $this->describe( $rside ) === Desc::PTR ) {            $result->type = $rside->type;         }         else {            $result->type = $this->createIntType();            $result->type->unchecked = true;            if ( $result->constant ) {               $result->inhabitant = $lside->inhabitant + $rside->inhabitant;               $result->type->value = $result->inhabitant;            }         }         break;      case \Binary::OP_SUB:         $result->type = $this->createIntType();         $result->type->unchecked = true;         if ( $result->constant ) {            $result->inhabitant = $lside->inhabitant - $rside->inhabitant;            $result->type->value = $result->inhabitant;         }         break;      case \Binary::OP_MUL:         $result->type = $this->createIntType();         $result->type->unchecked = true;         if ( $result->constant ) {            $result->inhabitant = $lside->inhabitant * $rside->inhabitant;            $result->type->value = $result->inhabitant;         }         break;      case \Binary::OP_DIV:         $result->type = $this->createIntType();         $result->type->unchecked = true;         if ( $result->constant ) {            $result->inhabitant = intdiv( $lside->inhabitant, $rside->inhabitant );            $result->type->value = $result->inhabitant;         }         break;      case \Binary::OP_MOD:         $result->type = $this->createIntType();         $result->type->unchecked = true;         if ( $result->constant ) {            $result->inhabitant = $lside->inhabitant % $rside->inhabitant;            $result->type->value = $result->inhabitant;         }         break;      default:         UNREACHABLE();      }      $binary->implementer = \Implementer::INT;      return $result;   }   private function checkBinaryBool( \Binary $binary, Value $lside,      Value $rside ): Value {      $valid = false;      if ( $this->describe( $rside ) === Desc::BOOL ) {         switch ( $binary->op ) {         case \Binary::OP_EQ:         case \Binary::OP_NEQ:            $valid = true;            break;         default:            break;         }      }      if ( ! $valid ) {         $this->user->diag( DIAG_ERR, $binary->pos,            "invalid operation: `%s` %s `%s`",            $this->presentType( $lside->type ),            $binary->presentOperator(),            $this->presentType( $rside->type ) );         $this->user->bail();      }      $result = new Value();      $result->evaluable = ( $lside->evaluable && $rside->evaluable );      $result->constant = ( $lside->constant && $rside->constant );      switch ( $binary->op ) {      case \Binary::OP_EQ:         $result->type = $this->createBoolType();         if ( $result->constant ) {            $result->inhabitant = $lside->inhabitant === $rside->inhabitant ? 1 : 0;            $result->type->value = $result->inhabitant;         }         break;      case \Binary::OP_NEQ:         $result->type = $this->createBoolType();         if ( $result->constant ) {            $result->inhabitant = $lside->inhabitant !== $rside->inhabitant ? 1 : 0;            $result->type->value = $result->inhabitant;         }         break;      default:         UNREACHABLE();      }      return $result;   }   private function checkBinaryStr( \Binary $binary, Value $lside,      Value $rside ): Value {      $valid = false;      if ( $this->describe( $rside ) === Desc::STR ) {         switch ( $binary->op ) {         case \Binary::OP_EQ:         case \Binary::OP_NEQ:            $valid = true;            break;         default:            break;         }      }      if ( ! $valid ) {         $this->user->diag( DIAG_ERR, $binary->pos,            "invalid operation: `%s` %s `%s`",            $this->presentType( $lside->type ),            $binary->presentOperator(),            $this->presentType( $rside->type ) );         $this->user->bail();      }      $result = new Value();      $result->evaluable = ( $lside->evaluable && $rside->evaluable );      $result->constant = ( $lside->constant && $rside->constant );      switch ( $binary->op ) {      case \Binary::OP_EQ:         $result->type = $this->createBoolType();         if ( $result->constant ) {            $result->inhabitant = $lside->inhabitant === $rside->inhabitant ? 1 : 0;            $result->type->value = $result->inhabitant;         }         break;      case \Binary::OP_NEQ:         $result->type = $this->createBoolType();         if ( $result->constant ) {            $result->inhabitant = $lside->inhabitant !== $rside->inhabitant ? 1 : 0;            $result->type->value = $result->inhabitant;         }         break;      default:         UNREACHABLE();      }      return $result;   }   private function checkBinaryPtr( \Binary $binary, Value $lside,      Value $rside ): Value {      $valid = false;      switch ( $binary->op ) {      case \Binary::OP_EQ:      case \Binary::OP_NEQ:      case \Binary::OP_LT:      case \Binary::OP_LTE:      case \Binary::OP_GT:      case \Binary::OP_GTE:         if ( $this->describe( $rside ) === Desc::PTR ) {            if ( ! $this->isInstanceOf( $rside, $lside->type ) ) {               $this->err( $binary->pos,                  "pointers of different type" );            }            $valid = true;         }         break;      case \Binary::OP_ADD:         if ( $this->describe( $rside ) === Desc::INT ) {            $valid = true;         }         break;      case \Binary::OP_SUB:         switch ( $this->describe( $rside ) ) {         case Desc::INT:            $valid = true;            break;         case Desc::PTR:            if ( ! $this->isInstanceOf( $rside, $lside->type ) ) {               $this->err( $binary->pos,                  "pointers of different type" );            }            $valid = true;            break;         }      default:         break;      }      if ( ! $valid ) {         $this->user->diag( DIAG_ERR, $binary->pos,            "invalid operation: `%s` %s `%s`",            $this->presentType( $lside->type ),            $binary->presentOperator(),            $this->presentType( $rside->type ) );         $this->user->bail();      }      $result = new Value();      $result->evaluable = ( $lside->evaluable && $rside->evaluable );      $result->constant = ( $lside->constant && $rside->constant );      switch ( $binary->op ) {      case \Binary::OP_EQ:      case \Binary::OP_NEQ:      case \Binary::OP_LT:      case \Binary::OP_LTE:      case \Binary::OP_GT:      case \Binary::OP_GTE:         $result->type = $this->createBoolType();         break;      case \Binary::OP_ADD:         $result->type = $lside->type;         break;      case \Binary::OP_SUB:         if ( $this->describe( $rside ) === Desc::PTR ) {            $result->type = $this->createIntType();         }         else {            $result->type = $lside->type;         }         break;      default:         UNREACHABLE();      }      $binary->implementer = \Implementer::PTR;      return $result;   }   private function checkBinaryStruct( \Binary $binary, Value $lside,      Value $rside ): Value {      $operator = null;      switch ( $binary->op ) {      case \Binary::OP_EQ:         $operator = $lside->type->structure->operators->eq;         break;      case \Binary::OP_NEQ:         $operator = $lside->type->structure->operators->neq;         break;      case \Binary::OP_LT:         $operator = $lside->type->structure->operators->lt;         break;      case \Binary::OP_LTE:         $operator = $lside->type->structure->operators->lte;         break;      case \Binary::OP_GT:         $operator = $lside->type->structure->operators->gt;         break;      case \Binary::OP_GTE:         $operator = $lside->type->structure->operators->gte;         break;      case \Binary::OP_ADD:         $operator = $lside->type->structure->operators->add;         break;      case \Binary::OP_SUB:         $operator = $lside->type->structure->operators->sub;         break;      case \Binary::OP_MUL:         $operator = $lside->type->structure->operators->mul;         break;      case \Binary::OP_DIV:         $operator = $lside->type->structure->operators->div;         break;      case \Binary::OP_MOD:         $operator = $lside->type->structure->operators->mod;         break;      }      if ( $operator == null ) {         printf( "error: operation not supported for %s type\n",            $lside->type->structure->name );         throw new \Exception();      }      if ( ! $this->isValidCall( $operator, [ $lside, $rside ] ) ) {         printf( "error: invalid operands for operator for %s type\n",            $lside->type->structure->name );         throw new \Exception();      }      $binary->type = $operator->returnType;      $result = new Value();      $result->type = $binary->type;      $result->evaluable = ( $lside->evaluable && $rside->evaluable );      $result->constant = ( $lside->constant && $rside->constant );      if ( $result->constant ) {         if ( $this->describe( $result ) === Desc::INT ) {            switch ( $binary->op ) {            case \Binary::OP_ADD:               $result->inhabitant = $lside->inhabitant + $rside->inhabitant;               $result->type->refinements[ 'value' ] = $result;               break;            }         }      }      return $result;   }   private function checkBinaryStructInfo( \Binary $binary, Value $lside,      Value $rside ): Value {      $type = null;      switch ( $binary->op ) {      case \Binary::OP_EQ:      case \Binary::OP_NEQ:         $type = $this->createBoolType();         break;      default:         printf( "error: operation not supported for `Struct` type\n" );         throw new \Exception();      }      $result = new Value();      $result->type = $type;      $result->evaluable = ( $lside->evaluable && $rside->evaluable );      $result->constant = true;      return $result;   }   private function checkPrefix( \Node $node ): Value {      if ( $node instanceof \Unary ) {         return $this->checkPrefixUnary( $node );      }      else {         return $this->checkPossibleLike( $node );      }   }   private function checkPrefixUnary( \Unary $unary ): Value {      switch ( $unary->op ) {      case UOP_PRE_INC:      case UOP_PRE_DEC:         return $this->checkIncrement( $unary );      }      $operand = $this->checkPrefix( $unary->operand );      if ( $this->describe( $operand ) === Desc::INT ) {         return $this->checkPrefixUnaryInt( $unary, $operand );      }      else if ( $operand->type->spec == TYPESPEC_STRUCT ) {         switch ( $unary->op ) {         case UOP_MINUS:            $operator = $operand->type->structure->operators->minus;            break;         case UOP_PLUS:            $operator = $operand->type->structure->operators->plus;            break;         case UOP_PRE_INC:            $operator = $operand->type->structure->operators->preInc;            break;         case UOP_PRE_DEC:            $operator = $operand->type->structure->operators->preDec;            break;         case UOP_ADDR_OF:            return $this->checkBorrowOf( $unary, $operand );         default:            throw new \Exception();         }         if ( $operator == null ) {            printf( "error: operation not supported for %s type\n",               $operand->type->structure->name );            throw new \Exception();         }         if ( ! $this->isValidCall( $operator, [ $operand ] ) ) {            printf( "error: invalid operands for operator for %s type\n",               $operand->type->structure->name );            throw new \Exception();         }         $unary->type = $operator->returnType;         $result = new Value();         $result->evaluable = true;         $result->type = $unary->type;         switch ( $operand->type->structure->name ) {         case 'Int':            switch ( $unary->op ) {            case UOP_MINUS:               $result->inhabitant = -$operand->inhabitant;               break;            }         }         return $result;      }      else {         $this->user->diag( DIAG_ERR, $unary->pos,            "invalid operation: %s `%s`", $unary->presentOperator(),            $this->presentType( $operand->type ) );         $this->user->bail();      }   }   private function checkPrefixUnaryInt( \Unary $unary,      Value $operand ): Value {      $result = new Value();      $result->evaluable = $operand->evaluable;      $result->constant = $operand->constant;      switch ( $unary->op ) {      case UOP_MINUS:         $result->type = $this->createIntType();         if ( $result->constant ) {            $result->inhabitant = - $operand->inhabitant;            $result->type->value = $result->inhabitant;         }         break;      case UOP_PLUS:         $result->type = $this->createIntType();         if ( $result->constant ) {            $result->inhabitant = $operand->inhabitant;            $result->type->value = $result->inhabitant;         }         break;      case UOP_ADDR_OF:         return $this->checkBorrowOf( $unary, $operand );      default:         $result = $this->err( $unary->pos,            'invalid operation: %s `%s`', $unary->presentOperator(),            $this->presentType( $operand->type ) );      }      return $result;   }   private function checkIncrement( \Unary $unary ): Value {      $operand = $this->checkPrefix( $unary->operand );      switch ( $this->describe( $operand ) ) {      case Desc::PTR:         return $this->checkIncrementPtr( $unary, $operand );      }      if ( $operand->type->spec !== TYPESPEC_STRUCT ) {         throw new \Exception();      }      switch ( $unary->op ) {      case UOP_PRE_INC:         $operator = $operand->type->structure->operators->preInc;         break;      case UOP_PRE_DEC:         $operator = $operand->type->structure->operators->preDec;         break;      default:         throw new \Exception();      }      if ( $operator == null ) {         printf( "error: operation not supported for %s type\n",            $operand->type->structure->name );         throw new \Exception();      }      if ( ! $this->isValidCall( $operator, [ $operand ] ) ) {         printf( "error: invalid operands for operator for %s type\n",            $operand->type->structure->name );         throw new \Exception();      }      if ( $operand->binding == null ) {         $this->user->diag( DIAG_ERR, $unary->pos,            "`%s` operator expects a binding for an operand",            $unary->op == UOP_PRE_INC ? '++' : '--' );         $this->user->bail();      }      $unary->type = $operator->returnType;      $result = new Value();      $result->evaluable = true;      $result->type = $unary->type;      return $result;   }   private function checkIncrementPtr( \Unary $unary,      Value $operand ): Value {      $unary->type = $operand->type;      $result = new Value();      $result->type = $unary->type;      $result->evaluable = true;      return $result;   }   private function checkBorrowOf( \Unary $unary, Value $operand ): Value {      $unary->type = $operand->type;      $result = new Value();      $result->evaluable = true;      //$result->borrowed = true;      //$result->binding = $operand->binding;      $result->type = clone $unary->type;      $result->type->borrowed = true;      $result->type->mutable = false;      if ( $operand->exposed ) {         $result->type->mutable = true;      }      return $result;   }   private function checkPossibleLike( \Node $node ): Value {      if ( $node instanceof \Like ) {         return $this->checkLike( $node );      }      else {         return $this->checkSuffix( $node );      }   }   private function checkLike( \Like $like ): Value {      $operand = $this->checkSuffix( $like->operand );      $result = $this->checkPattern( $operand, $like->pattern );      //$result = new Value();      //$result->type = $this->typeChecker->createBoolType();      //$result->evaluable = $operand->evaluable;      return $result;   }   /**    * @param MatchArm[] $arms    */   public function matchAgainstArms( Value $operand, array $arms ): Value {      $union = new AnonymousUnion( $this->samenessChecker,         $this->typeDescriber );      foreach ( $arms as $arm ) {         $this->scope->enter();         foreach ( $arm->patterns as $pattern ) {            $this->checkPattern( $operand, $pattern );         }         $this->scope->enter();         $result = $this->exprChecker->checkBlockStmt( $arm->body );         $this->scope->leave();         $union->addMember( $result->type );         $this->scope->leave();      }      $result = new Value();      $result->type = $union->createType();      return $result;   }   private function checkPattern( Value $operand,      \Pattern $pattern ): Value {      switch ( $pattern->type ) {      case PATTERN_NAME:         switch ( $this->describe( $operand ) ) {         case Desc::ENUM:            return $this->checkEnumNamePattern( $operand, $pattern );         case Desc::INT:         case Desc::STRUCT:            $this->checkNamePatternAgainstStruct( $pattern,               $operand->type->structure );            break;         default:            return $this->err( $pattern->pos,               'name pattern cannot be used with the specified operand' );         }         break;      case PATTERN_INTEGER_LITERAL:         return $this->checkIntegerLiteralPattern( $operand, $pattern );      default:         throw new \Exception();      }      return new Value();   }   private function checkEnumNamePattern( Value $operand,      \Pattern $pattern ): Value {      $binding = $this->scope->get( $pattern->name );      if ( $binding === null || $binding->value === null ) {         $this->user->diag( DIAG_ERR, $pattern->pos,            "`%s` not found", $pattern->name );         $this->user->bail();      }      $type = new Type();      switch ( $this->describe( $binding->value ) ) {      case Desc::STRUCT_TYPE:         $type->spec = TYPESPEC_STRUCT;         $type->structure = $binding->value->type->structure;         switch ( $type->structure->builtin ) {         case BUILTIN_STRUCTURE_INT:         case BUILTIN_STRUCTURE_BOOL:         case BUILTIN_STRUCTURE_STR:            $type->borrowed = true;            break;         }         break;      }      $enumerator = $this->instanceChecker->findEnumerator(         $operand->type->enumeration, $type );      $type->value = $enumerator;      if ( ! ( $enumerator instanceof \Enumerator ) ) {         $this->user->diag( DIAG_ERR, $pattern->pos,            "`%s` not an enumerator of `%s`", $pattern->name,            $this->typePresenter->presentEnumeration(               $operand->type->enumeration ) );         $this->user->bail();      }      /*      if ( ! $this->isEnumeratorOf( $enumerator,         $operand->type->enumeration ) ) {         $this->user->diag( DIAG_ERR, $pattern->pos,            "`%s` not an enumerator of the correct type",            $pattern->name );         $this->user->bail();      }      */      $pattern->match = MATCH_ENUM_TAG;      $pattern->enumerator = $enumerator;      if ( ! empty( $pattern->args ) ) {         $pattern->match = MATCH_ENUMERATOR;      }      $count = 0;      foreach ( $pattern->args as $arg ) {         if ( $count < count( $enumerator->params ) ) {            switch ( $arg->type ) {            case PATTERN_INTEGER_LITERAL:               if ( ! $this->instanceChecker->isInstanceOf(                  $this->typeChecker->createIntType(),                  $enumerator->params[ $count ]->type ) ) {                  $this->user->diag( DIAG_ERR, $arg->pos,                     "argument pattern of incorrect type" );                  $this->user->bail();               }               break;            case PATTERN_BOOL_LITERAL:               if ( ! $this->instanceChecker->isInstanceOf(                  $this->typeChecker->createBoolType(),                  $enumerator->params[ $count ]->type ) ) {                  $this->user->diag( DIAG_ERR, $arg->pos,                     "argument pattern of incorrect type" );                  $this->user->bail();               }               break;            default:               throw new \Exception();            }         }         else if ( $enumerator->structure !== null ) {            switch ( $arg->type ) {            case PATTERN_NAME:               $this->checkNamePatternAgainstEnumStructArg( $arg,                  $enumerator->structure );               break;            default:               throw new \Exception();            }         }         else {            $this->user->diag( DIAG_ERR, $pattern->pos,               "too many arguments for enumerator `%s` pattern",               $pattern->name );            $this->user->bail();         }         ++$count;      }      $result = new Value();      $result->type = $this->createBoolType();      $true = new Value();      $true->type = $this->createBoolType();      $true->inhabitant = 1;      $refinement = new \Refinement();      $refinement->target = $operand;      $refinement->type = $type;      $refinement->result = $true;      $result->type->refinements[] = $refinement;      return $result;/*      foreach ( $pattern->namedArgs->args as $name => $arg ) {         var_dump( $name );      }*/   }   private function checkNamePatternAgainstEnumStructArg( \Pattern $pattern,      \Structure $structure ): void {      $param = $pattern->param;      if ( $param === '' ) {         $param = $pattern->name;      }      $member = $structure->findMember( $param );      if ( $member === null ) {         $this->user->diag( DIAG_ERR, $pattern->pos,            "`%s` not a member of struct `%s`", $param,            $structure->name );         $this->user->bail();      }      $var = new \Variable();      $var->pos = $pattern->pos;      if ( $member->type->spec !== TYPESPEC_STRUCT ) {         $var->type->structure = $structure;         $var->type->spec = TYPESPEC_STRUCT;      }      else {         $var->type = $member->type;      }      $this->scope->bind( $pattern->name, $var );   }   private function checkNamePatternAgainstStruct( \Pattern $pattern,      \Structure $structure ): void {      $targetStructure = $this->scope->get( $pattern->name )?->node;      if ( ! ( $targetStructure instanceof \Structure ) ) {         $this->user->diag( DIAG_ERR, $pattern->pos,            "`%s` not a struct", $pattern->name );         $this->user->bail();      }      if ( $targetStructure !== $structure ) {         $this->user->diag( DIAG_ERR, $pattern->pos,            "`%s` does not match struct `%s`", $structure->name,            $targetStructure->name );         $this->user->bail();      }      $count = 0;      foreach ( $pattern->args as $arg ) {         if ( $count < count( $structure->members ) ) {            $member = $structure->members[ $count ];            switch ( $arg->type ) {            case PATTERN_INTEGER_LITERAL:            /*               if ( ! $this->typeChecker->isInstanceOf(                  $this->typeChecker->getIntType(),                  $enumerator->params[ $count ]->type ) ) {                  $this->user->diag( DIAG_ERR, $arg->pos,                     "argument pattern of incorrect type" );                  $this->user->bail();               }            */               break;            case PATTERN_BOOL_LITERAL:            /*               if ( ! $this->typeChecker->isInstanceOf(                  $this->typeChecker->getBoolType(),                  $enumerator->params[ $count ]->type ) ) {                  $this->user->diag( DIAG_ERR, $arg->pos,                     "argument pattern of incorrect type" );                  $this->user->bail();               }            */               break;            case PATTERN_NAME:               $this->checkNamePatternAgainstEnumStructArg( $arg, $structure );               break;            default:               throw new \Exception();            }         }         else {            $this->user->diag( DIAG_ERR, $pattern->pos,               "too many arguments for enumerator `%s` pattern",               $pattern->name );            $this->user->bail();         }         ++$count;      }   }   private function checkIntegerLiteralPattern( Value $operand,      \Pattern $pattern ): Value {      $intType = $this->typeChecker->createIntType();      if ( ! $this->isInstanceOf( $operand, $intType ) ) {         return $this->err( $pattern->pos,            'match condition not of `%s` type', $intType->structure->name );      }      return new Value();   }   private function checkSuffix( \Node $node ): Value {      if ( $node instanceof \Call ) {         return $this->checkCall( $node );      }      else if ( $node instanceof \Access ) {         return $this->checkAccess( $node );      }      else if ( $node instanceof \Subscript ) {         return $this->checkSubscript( $node );      }      else if ( $node instanceof \Propagation ) {         return $this->checkPropagation( $node );      }      else {         return $this->checkPrimary( $node );      }   }   private function checkCall( \Call $call ): Value {      $operand = $this->checkSuffix( $call->operand );      switch ( $this->describe( $operand ) ) {      case Desc::STRUCT:         if ( $operand->method ) {            $r = $this->checkFuncCall( $call, $operand );            return $r;         }         return $this->checkStructCall( $call, $operand );      case Desc::STRUCT_TYPE:         return $this->checkStructTypeCall( $call, $operand );      case Desc::ENUM_TYPE:         return $this->checkEnumTypeCall( $call, $operand );      case Desc::ENUM:         return $this->checkEnumeratorCall( $call, $operand );      default:         return $this->checkFuncCall( $call, $operand );      }   }   public function checkStructCall( \Call $call, Value $operand ): Value {      if ( ! $operand->type->structure->homogeneous ) {         $this->err( $call->pos,            "cannot access a heterogeneous struct with a numeric index" );      }      if ( count( $call->args ) !== 1 ) {         $this->err( $call->pos,            "expecting 1 argument" );      }      foreach ( $call->args as $arg ) {         $index = $this->checkExpr( $arg->expr );         if ( $this->describe( $index ) !== Desc::INT ) {            $this->err( $arg->expr->pos, "argument must be an integer" );         }      }      $call->structure = $operand->type->structure;      $call->type = CALL_STRUCTURE_VALUE;      $value = new Value();      $value->type = $operand->type->structure->members[ 0 ]->type;      return $value;   }   public function checkStructTypeCall( \Call $call, Value $operand ): Value {      switch ( $operand->type->structure->builtin ) {      case BUILTIN_STRUCTURE_VEC:         return $this->checkVecStructCall( $call, $operand );      }      $structure = $operand->type->structure;      if ( ( $this->isInsideVirtExpr() ||         ! empty( $this->unresolvedFuncs ) ) && ! $structure->resolved ) {         $this->declChecker->checkStruct( $structure );      }      if ( $structure->trait ) {         $this->err( $call->pos,            "attempting to initialize a trait value" );      }      if ( ! $structure->defined ) {         $this->err( $call->pos,            "struct `%s` is not defined", $structure->name );      }      $refinements = [];      $nonConstantArgs = false;      $count = 0;      foreach ( $structure->members as $member ) {         if ( $count < count( $call->args ) ) {            $arg = $call->args[ $count ];            $result = $this->checkExpr( $arg->expr );            $memberType = new Type();            $memberType->spec = $member->type->spec;            $memberType->structure = $member->type->structure;            $memberType->borrowed = $member->type->borrowed;            $memberType->args = $operand->type->args;            $memberType->placeholder = $member->type->placeholder;            $memberType->typeParam = $member->type->typeParam;            if ( ! $this->isInstanceOf( $result, $memberType ) ) {               $this->err( $arg->expr->pos,                  "initializer type (`%s`) different from expected type " .                  "(`%s`)", $this->presentType( $result->type ),                  $this->presentType( $member->type,                     $operand->type->args ) );            }            /*            if ( ! $this->isMemberVisible( $structure, $member ) ) {               $this->user->diag( DIAG_ERR, $arg->expr->pos,                  "cannot initialize `%s` member because it is not visible",                  $member->name );               $this->user->bail();            }            */            if ( $member->virtual &&               ! $arg->expr->constant ) {               $this->user->diag( DIAG_ERR, $arg->expr->pos,                  "virtual member `%s` requires a constant argument",                  $member->name );               $this->user->bail();            }            if ( ! $arg->expr->constant ) {               $nonConstantArgs = true;            }                        if ( $result->constant ) {               $refinements[ $member->name ] = $result;            }            if ( $result->binding !== null ) {               $result->binding->value = new Value();            }         }         else {            if ( $member->defaultInitializer === null ) {               $this->err( $call->pos, 'too little initializers' );            }            /*            if ( ! $this->isMemberVisible( $structure, $member ) ) {               $this->user->diag( DIAG_ERR, $call->pos,                  "cannot initialize struct `%s` because it has members " .                  "that are not visible", $structure->name );               $this->user->bail();            }            */         }         ++$count;      }      if ( $count < count( $call->args ) ) {         $this->err( $call->args[ $count ]->expr->pos,            'too many initializers' );      }      $call->structure = $structure;      $call->type = CALL_STRUCTURE;      $result = new Value();      $result->type->spec = TYPESPEC_STRUCT;      $result->type->structure = $structure;      $result->type->args = $operand->type->args;      $result->type->refinements = $refinements;      $result->type->mutable = $operand->type->mutable;      $result->type->borrowed = $operand->type->borrowed;      $result->evaluable = true;      $result->exposed = $operand->exposed;      if ( ! $nonConstantArgs ) {         $result->constant = true;      }      return $result;   }   public function checkVecStructCall( \Call $call, Value $operand ): Value {      $structure = $operand->type->structure;      $nonConstantArgs = false;      foreach ( $call->args as $arg ) {         $result = $this->checkExpr( $arg );         /*         if ( ! $this->typeChecker->isInstanceOf( $result->type,            $this->typeChecker->getIntType() ) ) {            printf( "error: initializer has incorrect type\n" );            exit( 1 );         }         */         if ( ! $arg->constant ) {            $nonConstantArgs = true;         }      }      $call->structure = $structure;      $call->type = CALL_STRUCTURE;      $result = new Value();      $result->type->spec = TYPESPEC_STRUCT;      $result->type->structure = $structure;      $result->evaluable = true;      if ( ! $nonConstantArgs ) {         $result->constant = true;      }      return $result;   }   private function checkEnumTypeCall( \Call $call,      Value $operand ): Value {      $args = [];      foreach ( $call->args as $arg ) {         $result = $this->checkExpr( $arg->expr );         $args[] = $result;      }      if ( count( $args ) !== 1 ) {         $this->err( $call->pos, 'enum type must take a single argument' );      }      $name = $call->args[ 0 ]->name;      if ( $name === '' ) {         $this->err( $call->pos, 'missing name of enumerator' );      }      $selectedEnumerator = null;      foreach ( $operand->type->enumeration->body as $enumerator ) {         if ( $enumerator->name === $name ) {            $selectedEnumerator = $enumerator;            break;         }      }      if ( $selectedEnumerator === null ) {         $this->err( $call->pos, 'enumerator `%s` not found',            $name );      }      if ( ! $this->isInstanceOf( $args[ 0 ],         $selectedEnumerator->type ) ) {         $this->err( $call->args[ 0 ]->expr->pos,            'argument 1 of wrong type (`%s`), expecting `%s`',            $this->presentType( $args[ 0 ]->type ),            $this->presentType( $selectedEnumerator->type ) );      }      $call->type = CALL_ENUM;      $call->enumerator = $selectedEnumerator;      return $args[ 0 ];   }   private function checkEnumeratorCall( \Call $call,      Value $operand ): Value {      $args = [];      if ( $operand->method ) {         $args[] = $operand;      }      foreach ( $call->args as $arg ) {         $result = $this->checkExpr( $arg );         $args[] = $result;      }      $count = 0;      foreach ( $operand->enumerator->params as $param ) {         if ( $count < count( $args ) ) {            if ( ! $this->isInstanceOf( $args[ $count ], $param->type ) ) {               printf( "error: argument %d of wrong type\n", $count + 1 );               exit( 1 );            }         }         else {            if ( ! $param->defaultArg ) {               printf( "error: too little arguments\n" );               exit( 1 );            }         }         ++$count;      }      if ( $count < count( $call->args ) ) {         printf( "error: too many arguments\n" );         exit( 1 );      }      if ( count( $operand->type->substitutions ) !=         count( $operand->enumerator->enumeration->params ) ) {         printf( "error: missing type arguments\n" );         exit( 1 );      }      $call->type = CALL_ENUM;      $call->enumerator = $operand->enumerator;      return $operand;   }   private function checkFuncCall( \Call $call, Value $operand ): Value {      $checker = new FuncCallChecker( $this->typeDescriber,            $this->typePresenter, $this->instanceChecker, $this,         $this->typeChecker, $this->user, $call, $operand );      return $checker->check();   }   public function doesFuncNeedToBeResolved(): bool {      return ( $this->isInsideVirtExpr() || ! empty( $this->unresolvedFuncs ) );   }   private function isInsideVirtExpr(): bool {      return $this->exprChecker->isInsideVirtExpr();   }   public function resolveFunc( \Module $owner, \Func $func ): void {      // To avoid deep call stacks when resolving deeply nested function calls,      // check one function at a time. Any unresolved function calls within the      // checked function will be added onto a queue and resolved as well.      array_push( $this->unresolvedFuncs, $func );      array_push( $this->unresolvedFuncsOwners, $owner );      if ( count( $this->unresolvedFuncs ) == 1 ) {         while ( count( $this->unresolvedFuncs ) > 0 ) {            $this->resolveItem(               $this->unresolvedFuncsOwners[ 0 ],               $this->unresolvedFuncs[ 0 ] );            array_shift( $this->unresolvedFuncsOwners );            array_shift( $this->unresolvedFuncs );         }      }   }   private function resolveItem( \Module $module, \Func $func ): void {      // The unresolved queue might contain duplicate entries. Make sure      // duplicate entries are not re-checked.      if ( ! $func->resolved ) {         $this->moduleChecker->checkItemOutOfOrder( $module, $func );      }   }   private function getVarArgType( \Typing\Type $type ): \Typing\Type {      switch ( $this->describe( $type ) ) {      case Desc::STRUCT:         switch ( $type->structure->builtin ) {         case BUILTIN_STRUCTURE_VEC:            if ( $type->structure->name == 'Any' ) {               return 1;            }            return $this->typeChecker->createIntType();         }         break;      }      throw new \Exception();   }   private function callEnumerator( Value $operand, array $args ): Value {      $result = new Value();      $result->type->initialized = true;      return $result;   }   private function checkAccess( \Access $access ): Value {      $lside = $this->checkSuffix( $access->lside );      switch ( $this->describe( $lside ) ) {      case Desc::INT:      case Desc::UNCHECKED_INT:      case Desc::STR:      case Desc::BOOL:      case Desc::STRUCT:         return $this->accessStructMember( $access, $lside );      case Desc::TRAIT:         return $this->checkTraitAccess( $access, $lside );      case Desc::STRUCT_TYPE:         return $this->checkStructTypeAccess( $access, $lside );      case Desc::STRUCT_INFO:         return $this->checkStructInfoAccess( $access, $lside );      default:         $this->err( $access->pos, 'left side (`%s`) not a struct',            $this->presentType( $lside->type ) );      }   }   private function accessStructMember( \Access $access,      Value $lside ): Value {      $access->structure = $lside->type->structure;      $member = $this->findStructureMember( $lside->type->structure,         $access->memberName );      if ( ! is_null( $member ) ) {         return $this->selectStructMember( $access, $lside, $member );      }      else {         $structure = $lside->type->structure;         if ( $structure->methods !== null &&            array_key_exists( $access->memberName,               $structure->methods->funcTable ) ) {            return $this->selectMethod( $access, $lside,               $structure->methods->funcTable[ $access->memberName ] );         }         else {            $this->err( $access->pos, 'member `%s` not found on type `%s`',               $access->memberName,               $this->presentType( $lside->type ) );         }      }   }   private function findStructureMember( \Structure $structure,      string $name ): ?\StructureMember {      foreach ( $structure->members as $member ) {         if ( $member->name == $name ) {            if ( $this->isMemberVisible( $structure, $member ) ) {               return $member;            }            else {               return null;            }         }      }      return null;   }   private function isMemberVisible( \Structure $structure,      \StructureMember $member ): bool {      return ( $member->visible ||         $this->moduleChecker->isStructInModule( $structure ) );   }   private function selectStructMember( \Access $access, Value $lside,      \StructureMember $member ): Value {      //$spec = $member->type->getSpec( $lside->type->args );      if ( ! array_key_exists( $member->name, $lside->type->refinements ) ) {         $result = new Value();         $result->type = $member->type;         $result->type->borrowed = $member->type->borrowed;         if ( ! $member->type->borrowed ) {            $result->type->mutable = $lside->type->mutable;         }         $result->container = $lside->type;         $result->evaluable = $lside->evaluable;         $result->virtual = $member->virtual;         //$access->isBool = ( $result->type->spec == TYPESPEC_BOOL );         $lside->type->refinements[ $member->name ] = $result;      }      $access->type = ACCESS_MEMBER;      $result = $lside->type->refinements[ $member->name ];      $result->member = $member;      $result->memberName = $member->name;      $result->type->borrowed = $member->type->borrowed;      $result->mutableBinding = ( $lside->type->mutable &&         $member->mutable );      if ( ! $member->type->borrowed ) {         $result->type->mutable = $lside->type->mutable;      }      return $result;   }   private function selectMethod( \Access $access, Value $lside,      \Func $func ): Value {      $result = clone $lside;      $result->func = $func;      $result->method = true;      $access->method = $func;      $access->type = ACCESS_METHOD;      return $result;   }   private function checkTraitAccess( \Access $access,      Value $lside ): Value {      $member = $this->findTraitMember( $lside->type->trait,         $access->memberName );      if ( is_null( $member ) ) {         printf( "error: trait member `%s` not found\n", $access->memberName );         throw new \Exception();      }      $lside->func = $member->func;      //$lside->method = true;      $access->type = ACCESS_TRAIT_MEMBER;      return $lside;   }   private function findTraitMember( \TraitObj $trait,      string $name ): ?\TraitMember {      foreach ( $trait->members as $member ) {         if ( $member->func->name == $name ) {            return $member;         }      }      return null;   }   private function checkStructTypeAccess( \Access $access,      Value $lside ): Value {      return $this->checkStructInfoAccess( $access, $lside );   }   private function checkStructInfoAccess( \Access $access,      Value $lside ): Value {      if ( $access->memberName == 'size' ) {         $access->type = ACCESS_STRUCTURE_SIZE;         $result = new Value();         $result->type = $this->typeChecker->createIntType();         $result->evaluable = true;         $result->constant = true;         //$result->value = $lside->type->structure->size;         return $result;      }      else if ( $access->memberName == 'name' ) {         $access->type = ACCESS_STRUCTURE_NAME;         $result = new Value();         $result->type = $this->typeChecker->createStrType();         $result->evaluable = true;         $result->constant = true;         //$result->value = $lside->type->structure->size;         return $result;      }      else {         $this->task->user->diag( DIAG_ERR,            $access->pos, "member `%s` not found", $access->memberName );         $this->user->bail();      }   }   private function checkSubscript( \Subscript $subscript ): Value {      $operand = $this->checkSuffix( $subscript->operand );      /*      if ( count( $indexes ) != count( $operand->type->dims ) ) {         printf( "error: need %d indexes, but %d given\n",            count( $operand->type->dims ), count( $indexes ) );         throw new Exception();      }*/      //$subscript->dims = $operand->type->dims;      if ( $this->describe( $operand ) == Desc::PTR ) {         $subscript->isPointer = true;         $result = $this->deref( $subscript->pos, $operand,            $subscript->indexes );      }      else {         $this->err( $subscript->pos, 'operand of type `%s` does not ' .            'support the [] operator',            $this->presentType( $operand->type ) );      }      if ( $subscript->value !== null ) {         $this->checkSimpleExpr( $subscript->value );      }      return $result;   }   private function deref( \Lexing\Position $pos, Value $operand,      array $indexes ): Value {      if ( count( $indexes ) > 1 ) {         $this->err( $pos, "too many arguments for pointer dereference" );      }      if ( count( $indexes ) === 1 ) {         $index = $this->checkExpr( $indexes[ 0 ] );         if ( $this->describe( $index ) !== Desc::INT ) {            $this->err( $pos, "index must be of int type" );         }      }      $operand->type = $operand->type->args[ 0 ];      $operand->mutableBinding = true;      return $operand;   }   private function checkPropagation( \Propagation $propagation ): Value {      $operand = $this->checkSuffix( $propagation->operand );      return $operand;   }   private function checkPrimary( \Node $node ): Value {      if ( $node instanceof \Sizeof ) {         return $this->checkSizeof( $node );      }      else if ( $node instanceof \NameUsage ) {         return $this->checkNameUsage( $node );      }      else if ( $node instanceof \Structure ) {         return $this->checkStructType( $node );      }      else if ( $node instanceof \Enumeration ) {         return $this->checkEnumType( $node );      }      else if ( $node instanceof \Func ) {         return $this->checkFunc( $node );      }      else if ( $node instanceof \IntegerLiteral ) {         return $this->checkIntegerLiteral( $node );      }      else if ( $node instanceof \StringLiteral ) {         return $this->checkStringLiteral( $node );      }      else if ( $node instanceof \BoolLiteral ) {         return $this->checkBoolLiteral( $node );      }      else if ( $node instanceof \TypeLiteral ) {         return $this->checkTypeLiteral( $node );      }      else if ( $node instanceof \Tuple ) {         return $this->checkTuple( $node );      }      else {      var_dump( $node );         throw new \Exception();      }   }   private function checkSizeof( \Sizeof $sizeof ): Value {      $arg = $this->checkExpr( $sizeof->expr );      $sizeof->size = $this->sizeOfType( $arg->type );      $result = new Value();      $result->type = new \Typing\Type();      $result->type->spec = TYPESPEC_STRUCT;      $result->type->structure = $this->typeChecker->getIntStruct();      return $result;   }   private function checkNameUsage( \NameUsage $usage ): Value {      $this->determineModuleForNameUsage( $usage );      $binding = $this->scope->get( $usage->name, $usage->pos, $usage->module );      if ( $binding !== null ) {         $object = $binding->node;         if ( $object instanceof \ImportItem ) {            $object = $object->object;         }         if ( $binding->value->type->spec === TYPESPEC_UNRESOLVED ) {            $this->moduleChecker->checkItemOutOfOrder( $binding->module,               $binding->node );            $binding->value = null;            $binding = $this->scope->get( $usage->name, $usage->pos, $usage->module );         }         $value = $binding->value;         $usage->object = $object;         $usage->value = clone $value;         if ( $this->exprChecker->typeContext &&            $this->describeValue( $value ) !== Desc::STRUCT_TYPE ) {            $type = new Type();            $type->spec = TYPESPEC_VALUE;            $type->value = $value;            $type->name = $usage->name;            $value->type = $type;         }         if ( $usage->mutable ) {            if ( $this->describe( $value ) === Desc::STRUCT_TYPE ) {               $value->type->mutable = true;            }            else {               if ( $binding->value->type->borrowed ||                  ! $binding->value->type->mutable ) {                  $this->err( $usage->pos, 'cannot create a mutable handle to an ' .                     'immutable value' );               }            }         }         $value->exposed = $usage->mutable;         /*         if ( $object instanceof \Constant ) {            $value = $this->checkConstantUsage( $module, $object );         }         else if ( $object instanceof \Enumerator ) {            $value = $this->checkEnumeratorUsage( $module, $object );         }         else if ( $object instanceof \Param ) {            $value = $this->checkParamUsage( $usage, $object, $binding );         }         else if ( $object instanceof \Func ) {            $value = $this->checkFuncUsage( $usage, $module, $object );         }         else if ( $object instanceof \Let ) {            $value = $this->checkBindingUsage( $usage, $binding, $object );         }         else {            $this->user->diag( DIAG_INTERNAL | DIAG_ERR, $usage->pos,               'unhandled node type: %d', $object->nodeType );            $this->user->bail();         }         */         if ( $usage->argsListSpecified ) {            $value = $this->checkNameUsageSubscript( $usage, $value );         }         return $value;      }      else {         return $this->err( $usage->pos,            'unknown object `%s`', $usage->name );      }   }   private function determineModuleForNameUsage( \NameUsage $usage ): void {      $startingModule = $this->moduleChecker->getPrefixModule(         $usage->moduleName );      if ( $startingModule == null ) {         $this->user->diag( DIAG_ERR, $usage->moduleNamePos,            "`%s` is not an imported module", $usage->moduleName );         $this->user->bail();      }      $usage->module = $startingModule;   }   private function checkForItemUsage( \NameUsage $usage,      \ForItem $item ): Value {      $result = new Value();      $result->type = $item->type;      $result->evaluable = true;      return $result;   }   private function checkStructUsage( \NameUsage $usage,      \Structure $structure ): Value {      $args = [];      $count = 0;      foreach ( $usage->args as $arg ) {         $argResult = $this->checkExpr( $arg );         if ( $this->describe( $argResult ) !== Desc::STRUCT_TYPE ) {            $this->user->diag( DIAG_ERR, $arg->pos,               "argument %d must be a type", $count + 1 );            $this->user->bail();         }         $args[] = $argResult->type;         ++$count;      }      if ( $count !== count( $structure->params ) ) {         if ( $count > count( $structure->params ) ) {            $this->user->diag( DIAG_ERR, $usage->pos,               "too many type arguments (got %d, but expecting %d)", $count,               count( $structure->params ) );         }         else {            $this->user->diag( DIAG_ERR, $usage->pos,               "too few type arguments (got %d, but expecting %d)", $count,               count( $structure->params ) );         }         $this->user->bail();      }      $result = new Value();      $result->type->structure = $structure;      $result->type->spec = TYPESPEC_STRUCT_TYPE;      $result->type->args = $args;      $result->type->mutable = $usage->mutable;      $result->constant = true;      $result->evaluable = true;      //$result->type->name = $object->name;      //$declChecker = new DeclChecker( $this->scope, $this->task );      //$declChecker->checkType( $result->type );      return $result;   }   private function checkBindingUsage( \NameUsage $usage,      \Binding $binding, \Let $let ): Value {      //return $binding->value;      $result = clone $binding->value;      //$result->type = $let->type->createInstance();      //$result->type = $b->type;      $result->evaluable = true;      $result->constant = true;      $result->mutableBinding = $binding->rebindable;      $result->binding = $binding;      return $result;   }   private function checkNameUsageSubscript( \NameUsage $usage,      Value $lside ): Value {      switch ( $this->describe( $lside ) ) {      case Desc::STRUCT:         switch ( $lside->type->structure->builtin ) {         case BUILTIN_STRUCTURE_VEC:            return $this->checkVecSubscript( $usage, $lside );         case BUILTIN_STRUCTURE_PTR:         case BUILTIN_STRUCTURE_CONST_PTR:            return $this->checkPtrSubscript( $usage, $lside );         }         break;      case Desc::PTR:         return $this->checkPtrSubscript( $usage, $lside );      case Desc::GENERIC:         return $this->checkGenericSubscript( $usage, $lside );      }      throw new \Exception();   }   private function checkVecSubscript( \NameUsage $usage,      Value $lside ): Value {      if ( count( $usage->args ) !== 1 ) {         $this->user->diag( DIAG_ERR, $usage->pos,            "expecting 1 argument for []" );         $this->user->bail();      }      $index = $this->checkExpr( $usage->args[ 0 ] );      if ( ! $this->isInstanceOf( $index,         $this->typeChecker->createIntType() ) ) {         $this->user->diag( DIAG_ERR, $usage->pos,            "argument 1 must be of Int type" );         $this->user->bail();      }      $result = new Value();      $result->type = $this->typeChecker->createIntType();      $result->evaluable = true;      return $result;   }   private function checkPtrSubscript( \NameUsage $usage,      Value $lside ): Value {      return $this->deref( $usage->pos, $lside, $usage->args );   }   private function checkGenericSubscript( \NameUsage $usage,      Value $lside ): Value {      $args = [];      $argsTypes = [];      $count = 0;      foreach ( $usage->args as $arg ) {         $argResult = $this->checkExpr( $arg->expr );         if ( $count >= count( $lside->generic->params ) ) {            $this->user->diag( DIAG_ERR, $usage->pos,               "too many type arguments (got %d, but expecting %d)",               count( $usage->args ),               count( $lside->generic->params ) );            $this->user->bail();         }         $param = $lside->generic->params[ $count ];         if ( ! $this->isInstanceOf( $argResult, $param->type ) ) {            $this->user->diag( DIAG_ERR, $arg->expr->pos,               "argument %d type (`%s`) different from expected type (`%s`)",               $count + 1, $this->presentType( $argResult->type ),               $this->presentType( $param->type ) );            $this->user->bail();         }         /*         if ( $this->describe( $argResult ) !== Desc::STRUCT_TYPE ) {            $this->user->diag( DIAG_ERR, $arg->expr->pos,               "argument %d must be a type", $count + 1 );            $this->user->bail();         }         */         $args[] = $argResult;         $argsTypes[] = $argResult->type;         ++$count;      }      if ( $count !== count( $lside->generic->params ) ) {         $this->user->diag( DIAG_ERR, $usage->pos,            "too few type arguments (got %d, but expecting %d)", $count,            count( $lside->generic->params ) );         $this->user->bail();      }      return $this->expandGeneric( $lside->generic, $args );   }   public function expandGeneric( \Generic $generic, array $args ): Value {      $result = $this->evaluator->expandGeneric( $generic, $args );      $generic->computedValue = $result;      return $result;   }   private function createAstNode( Position $pos, Value $result ): \Node {      switch ( $this->describe( $generic->computedValue->type ) ) {      case Description::INT:         $node = new \IntegerLiteral();         //$node->pos =         break;      default:         throw new \Exception();      }   }   private function checkConstantUsage( \Module $module,      \Constant $constant ): Value {      if ( ! $constant->resolved ) {         $this->moduleChecker->checkItemOutOfOrder( $module, $constant );      }      $result = new Value();      $result->inhabitant = $constant->value;      $result->type = $constant->type;      //$result->type->value = $constant;      //$result->type->spec = TYPESPEC_VALUE;      $result->diag = $constant->diag;      return $result;   }   private function checkEnumeratorUsage( \Module $module,      \Enumerator $enumerator ): Value {      if (  ! $enumerator->enumeration->resolved ) {         $this->moduleChecker->checkItemOutOfOrder( $module, $enumerator );      }      $result = new Value();      $result->inhabitant = $enumerator->value;      $result->type->spec = TYPESPEC_ENUM;      $result->type->enumeration = $enumerator->enumeration;      $result->enumerator = $enumerator;      $result->evaluable = true;      $result->constant = true;      return $result;   }   private function checkParamUsage( \NameUsage $usage,      \Param $param, \Binding $binding ): Value {      if ( $binding->value === null ) {      /*         $result = new Result();         $result->type = $param->type;         $result->constant = $param->constant;         $result->evaluable = true;         $result->binding = $binding;         $binding->value = $result;               // Dereference.         if ( $usage->args !== null ) {            $result = $this->deref( $usage->pos, $result, $usage->args );         }      */         $binding->value = $param->value;      }      //return $binding->value;      $result = clone $binding->value;      if ( $usage->mutable && ( $binding->value->type->borrowed ||         ! $binding->value->type->mutable ) ) {         $this->err( $usage->pos, 'cannot create a mutable handle to an ' .            'immutable value' );      }      $result->exposed = $usage->mutable;      return $result;   }   private function checkFuncUsage( \NameUsage $usage, \Module $owner,      \Func $func ): Value {      $args = [];      $count = 0;      foreach ( $usage->args as $arg ) {         $argResult = $this->checkExpr( $arg );         if ( $this->describe( $argResult ) !== Desc::STRUCT_TYPE ) {            $this->user->diag( DIAG_ERR, $arg->pos,               "argument %d must be a type", $count + 1 );            $this->user->bail();         }         $args[] = $argResult->type;         ++$count;      }      if ( $count !== count( $func->typeParams ) ) {         if ( $count > count( $func->typeParams ) ) {            $this->user->diag( DIAG_ERR, $usage->pos,               "too many type arguments (got %d, but expecting %d)", $count,               count( $func->typeParams ) );         }         else {            $this->user->diag( DIAG_ERR, $usage->pos,               "too few type arguments (got %d, but expecting %d)", $count,               count( $func->typeParams ) );         }         $this->user->bail();      }      // NOTE: Resolving function here breaks the expression checker because      // the `func` property is not updated to the new function.      /*      if ( ! $func->resolved ) {         $this->moduleChecker->checkItemOutOfOrder( $owner, $func );      } */      $result = new Value();      $result->func = $func;      $result->type->args = $args;      $result->owner = $owner;      $result->evaluable = $func->evaluable;      return $result;   }   public function checkStructType( \Structure $structure ): Value {      $this->declChecker->checkStructLiteral( $structure );      $result = new Value();      $result->type->structure = $structure;      $result->type->spec = TYPESPEC_STRUCT_TYPE;      $result->constant = true;      $result->evaluable = true;      return $result;   }   public function checkEnumType( \Enumeration $enumeration ): Value {      $this->scope->bind( $enumeration->name, $enumeration );      $this->declChecker->checkEnum( $enumeration );      $result = new Value();      $result->type->enumeration = $enumeration;      $result->type->spec = TYPESPEC_ENUM_TYPE;      $result->constant = true;      $result->evaluable = true;      return $result;   }   public function checkFunc( \Func $func ): Value {      $this->declChecker->checkFunc( $func );      $result = new Value();      $result->func = $func;      $result->evaluable = $func->evaluable;      $result->constant = true;      $result->inhabitant = $func;      return $result;   }   public function checkIntegerLiteral( \IntegerLiteral $literal ): Value {      $structure = $this->typeChecker->getIntStruct();      $result = new Value();      $result->type->name = $structure->name;      $result->type->spec = TYPESPEC_STRUCT;      $result->type->value = $literal->value;      #$result->type->borrowed = true;      $result->type->structure = $structure;      $result->inhabitant = $literal->value;      $result->constant = true;      $result->evaluable = true;      return $result;   }   public function checkStringLiteral( \StringLiteral $literal ): Value {      $structure = $this->typeChecker->getStrStruct();      $result = new Value();      $result->type->name = $structure->name;      $result->type->spec = TYPESPEC_STRUCT;      $result->type->value = $literal->index;      #$result->type->borrowed = true;      $result->type->structure = $structure;      $result->inhabitant = $literal->value;      $result->constant = true;      $result->evaluable = true;      return $result;   }   public function checkBoolLiteral( \BoolLiteral $literal ): Value {      $structure = $this->typeChecker->getBoolStruct();      $result = new Value();      $result->type->name = $structure->name;      $result->type->spec = TYPESPEC_STRUCT;      $result->type->value = $literal->value;      $result->type->structure = $structure;      #$result->type->borrowed = true;      $result->inhabitant = $literal->value;      $result->constant = true;      $result->evaluable = true;      return $result;   }   public function checkTypeLiteral( \TypeLiteral $literal ): Value {      $type = $this->exprChecker->checkTypeExpr( $literal->typeExpr );      $literal->type = $type;      $result = new Value();      $result->type->spec = TYPESPEC_STRUCT;      $result->type->structure = $this->task->builtinModule->typeStruct;      $result->inhabitant = $literal->type;      $result->constant = true;      return $result;   }   private function checkTuple( \Tuple $tuple ): Value {      if ( count( $tuple->args ) > 0 ) {         return $this->checkTupleWithArgs( $tuple );      }      else {         $tuple->structure = new \Structure();         return new Value();      }   }   private function checkTupleWithArgs( \Tuple $tuple ): Value {      $nonConst = false;      $unnamedFields = 0;      $namedFields = 0;      $args = [];      $element = null;      $homogeneous = false;      foreach ( $tuple->args as $arg ) {         $value = $this->checkExpr( $arg->expr );         $value->name = $arg->name;         if ( ! $value->constant ) {            $nonConst = true;         }         $args[] = $value;         /*         if ( $arg->tag !== '' ) {            ++$namedFields;            if ( $unnamedFields > 0 ) {               $this->err( $arg->pos,                  "value tagged, but previous value was not" );            }         }         else {            ++$unnamedFields;            if ( $namedFields > 0 ) {               $this->err( $arg->pos,                  "missing tag for value" );            }         }         */         // To prevent the accidental mistake of forgetting the colon         // character and ending up with an assignment, prevent an assignment         // from being used as an element for a tuple.         if ( $value->assigned && $arg->name === '' &&            count( $tuple->args ) > 1 ) {            $this->err( $arg->expr->pos,               'assignment cannot be a tuple element' );         }         if ( $element !== null ) {            if ( ! $this->isInstanceOf( $value, $element->type ) ) {               $homogeneous = false;            }         }         else {            $element = clone $value;            //$element->type->value = null;            $homogeneous = true;         }      }      if ( count( $args ) > 1 || ( count( $args ) === 1 &&         $args[ 0 ]->name !== '' ) ) {         $structure = new \Structure();         $structure->homogeneous = $homogeneous;         $count = 0;         foreach ( $tuple->args as $arg ) {            $member = new \StructureMember();            $member->name = $arg->name;            $member->type = $args[ $count ]->type;            $member->visible = true;            #$member->mutable = true;            $structure->members[] = $member;            ++$count;         }         $result = new Value();         $result->type->structure = $structure;         $result->type->spec = TYPESPEC_STRUCT;         $result->constant = ( ! $nonConst );         $result->members = $args;         #$result->type->mutable = true;         $tuple->structure = $structure;         $this->moduleChecker->appendTupleStruct( $structure );         return $result;      }      else {         $tuple->structure = end( $args )->type->structure;         return end( $args );      }   }   private function describe( Value|Type $value ): Desc {      if ( $value instanceof Value ) {         return $this->typeDescriber->describe( $value->type );      }      else {         return $this->typeDescriber->describe( $value );      }   }   private function createIntType(): Type {      return $this->typeChecker->createIntType();   }   private function createBoolType(): Type {      return $this->typeChecker->createBoolType();   }   public function checkExpr( \Expr $expr ): Value {      return $this->exprChecker->checkExpr( $expr );   }}